import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as d,o as n,c as s,b as e,d as t,e as r,a as c}from"./app-5LVKShiE.js";const a={},u=e("h1",{id:"通信流程",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#通信流程"},[e("span",null,"通信流程")])],-1),h=e("h2",{id:"参考资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考资料"},[e("span",null,"参考资料")])],-1),_={href:"https://www.hentai.org.cn/article?id=8",target:"_blank",rel:"noopener noreferrer"},p=c('<h2 id="主要角色" tabindex="-1"><a class="header-anchor" href="#主要角色"><span>主要角色</span></a></h2><ul><li>用户</li><li>指令服务：指的是 <strong>JT/T 808</strong> 服务</li><li>流媒体服务：指的是 <strong>JT/T 1078</strong> 服务</li><li>终端设备：指的是车载终端</li><li>订阅者：这里只是一个泛称 <ul><li>可以是音视频播放器、其他推流服务(比如 <code>Nginx</code>)、其他进程、文件、<code>socket</code> ……</li><li>常用的就是 <strong>flv播放器</strong> 比如 <code>VLC</code>、<code>flv.js</code>、<code>mpegts.js</code> 等</li></ul></li></ul><h2 id="通信流程-1" tabindex="-1"><a class="header-anchor" href="#通信流程-1"><span>通信流程</span></a></h2>',3),m={class:"demo"},f=["src"],g=c('<ul><li>1). 用户请求调阅某个终端的某个通道的流媒体数据</li><li>2). 指令服务向终端设备发送 <code>0x9101</code> 指令, <ul><li><code>0x9101</code> 指令中包含了 流媒体服务的 <code>ip</code>, <code>port</code>, <code>通道号</code> 等信息</li></ul></li><li>3). 终端设备收到 <code>0x9101</code> 指令之后，开始向流媒体服务 <code>ip:port</code> 推送音视频码流</li><li>4). 流媒体服务收到码流数据，做一些必要的转换，然后向订阅者发送(转换之后的)流媒体数据 <ul><li>转换的目的是为了满足订阅者的播放需求</li><li>一般常见的终端视频格式都是 <code>H.264</code>，但是播放器一般都不能直接播放 <code>H.264</code>，所以要做进一步的转码(比如 <code>H.264 -&gt; FLV</code>)</li><li>相比于视频，音频格式就很多了，比如 <code>G.711</code>、<code>G.726</code>、<code>ADPCM</code> 等；设备上传的通常都是压缩之后的音频数据，也需要做相应的解码以适应播放器的播放需求</li></ul></li><li>5). 订阅者播放流媒体数据 <ul><li>订阅者只是一个泛称,可以是音视频播放器、其他推流服务(比如 <code>Nginx</code>)、其他进程、文件、<code>socket</code> ……</li><li>可以直接播放，也可以将收到的码流数据保存到本地，也可以通过 <code>socket</code> 等方式发送给其他进程，也可以推流给其他流媒体服务</li></ul></li></ul><h2 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式"><span>实现方式</span></a></h2><p>上面的通信流程只是一种理论上的流程。在实际的实现中，可以根据自己的是实际需求做合理的调整。</p><ul><li>下发指令 <code>0x9101</code> 指令是通过 <strong>JT/T 808</strong> 服务(暂且称之为 <code>InstructionService</code>) 实现的 <ul><li><code>InstructionService</code> 一般都是多实例部署的</li><li>所以下发指令之前，还需确认你想调阅的设备到底在哪个 <code>InstructionService</code> 实例上?</li><li>所以在 <code>InstructionService</code> 之前应该还有个统一的&quot;控制台服务&quot;(暂且称之为 <code>ConsoleService</code>)</li><li><code>ConsoleService</code> 除了做负载均衡，实例选择的功能外，还应该有一些其他的功能，比如认证授权、权限管理、……</li></ul></li><li>订阅者 <ul><li>订阅者看你实际需求，一般都是音视频播放器</li><li>在逻辑上来说，订阅者和 <code>ConsoleService</code> 是独立的；但在实现上来说是可以耦合在一起的</li><li>比如本项目提供的 <code>jt-dashboard-server</code> 就是将订阅者和 <code>ConsoleService</code> 合二为一，提供了网页播放器</li></ul></li><li>物理视图 VS 逻辑视图 <ul><li>逻辑视图介绍了 <code>ConsoleService</code>、<code>InstructionService</code> 、 <code>流媒体服务</code> 和 <code>订阅者</code> 之间的关系</li><li>而具体的实现即物理视图不一定非要每个角色一个服务 <ul><li>看实际情况自行优化</li><li>可能每个角色都部署在同一个服务中(不推荐)</li><li>也可能每个角色都部署在各自不同的服务中</li><li>也可能挑选出某些角色合而为一</li></ul></li></ul></li></ul>',4),v={class:"demo"},x=["src"];function S(o,w){const l=d("ExternalLinkIcon");return n(),s("div",null,[u,h,e("ul",null,[e("li",null,[e("a",_,[t("JT/1078音视频传输协议开发指南"),r(l)])])]),p,e("p",m,[e("img",{src:o.$withBase("/img/1078/intro/1078-flow-0.png")},null,8,f)]),g,e("p",v,[e("img",{src:o.$withBase("/img/1078/intro/1078-flow-1.png")},null,8,x)])])}const C=i(a,[["render",S],["__file","communication-flow.html.vue"]]);export{C as default};
